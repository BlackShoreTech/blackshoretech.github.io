{"pageProps":{"codeSnippet":"from __future__ import annotations\n\nimport sys\n\n\nclass Letter:\n    def __init__(self, letter: str, freq: int):\n        self.letter: str = letter\n        self.freq: int = freq\n        self.bitstring: dict[str, str] = {}\n\n    def __repr__(self) -> str:\n        return f\"{self.letter}:{self.freq}\"\n\n\nclass TreeNode:\n    def __init__(self, freq: int, left: Letter | TreeNode, right: Letter | TreeNode):\n        self.freq: int = freq\n        self.left: Letter | TreeNode = left\n        self.right: Letter | TreeNode = right\n\n\ndef parse_file(file_path: str) -> list[Letter]:\n    \"\"\"\n    Read the file and build a dict of all letters and their\n    frequencies, then convert the dict into a list of Letters.\n    \"\"\"\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda l: l.freq)\n\n\ndef build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    \"\"\"\n    Run through the list of Letters and build the min heap\n    for the Huffman Tree.\n    \"\"\"\n    response: list[Letter | TreeNode] = letters  # type: ignore\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda l: l.freq)\n    return response[0]\n\n\ndef traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\n    \"\"\"\n    Recursively traverse the Huffman Tree to set each\n    Letter's bitstring dictionary, and return the list of Letters\n    \"\"\"\n    if type(root) is Letter:\n        root.bitstring[root.letter] = bitstring\n        return [root]\n    treenode: TreeNode = root  # type: ignore\n    letters = []\n    letters += traverse_tree(treenode.left, bitstring + \"0\")\n    letters += traverse_tree(treenode.right, bitstring + \"1\")\n    return letters\n\n\ndef huffman(file_path: str) -> None:\n    \"\"\"\n    Parse the file, build the tree, then run through the file\n    again, using the letters dictionary to find and print out the\n    bitstring for each letter.\n    \"\"\"\n    letters_list = parse_file(file_path)\n    root = build_tree(letters_list)\n    letters = {\n        k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()\n    }\n    print(f\"Huffman Coding  of {file_path}: \")\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            print(letters[c], end=\" \")\n    print()\n\n\nif __name__ == \"__main__\":\n    # pass the file path to the huffman function\n    huffman(sys.argv[1])\n"},"__N_SSG":true}
{"pageProps":{"codeSnippet":"\"\"\"\nThis is pure Python implementation of tree traversal algorithms\n\"\"\"\nfrom __future__ import annotations\n\nimport queue\n\n\nclass TreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.right = None\n        self.left = None\n\n\ndef build_tree():\n    print(\"\\n********Press N to stop entering at any point of time********\\n\")\n    check = input(\"Enter the value of the root node: \").strip().lower() or \"n\"\n    if check == \"n\":\n        return None\n    q: queue.Queue = queue.Queue()\n    tree_node = TreeNode(int(check))\n    q.put(tree_node)\n    while not q.empty():\n        node_found = q.get()\n        msg = f\"Enter the left node of {node_found.data}: \"\n        check = input(msg).strip().lower() or \"n\"\n        if check == \"n\":\n            return tree_node\n        left_node = TreeNode(int(check))\n        node_found.left = left_node\n        q.put(left_node)\n        msg = f\"Enter the right node of {node_found.data}: \"\n        check = input(msg).strip().lower() or \"n\"\n        if check == \"n\":\n            return tree_node\n        right_node = TreeNode(int(check))\n        node_found.right = right_node\n        q.put(right_node)\n\n\ndef pre_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    print(node.data, end=\",\")\n    pre_order(node.left)\n    pre_order(node.right)\n\n\ndef in_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    in_order(node.left)\n    print(node.data, end=\",\")\n    in_order(node.right)\n\n\ndef post_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    post_order(node.left)\n    post_order(node.right)\n    print(node.data, end=\",\")\n\n\ndef level_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order(root)\n    1,2,3,4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        node_dequeued = q.get()\n        print(node_dequeued.data, end=\",\")\n        if node_dequeued.left:\n            q.put(node_dequeued.left)\n        if node_dequeued.right:\n            q.put(node_dequeued.right)\n\n\ndef level_order_actual(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order_actual(root)\n    1,\n    2,3,\n    4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        list_ = []\n        while not q.empty():\n            node_dequeued = q.get()\n            print(node_dequeued.data, end=\",\")\n            if node_dequeued.left:\n                list_.append(node_dequeued.left)\n            if node_dequeued.right:\n                list_.append(node_dequeued.right)\n        print()\n        for node in list_:\n            q.put(node)\n\n\n# iteration version\ndef pre_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order_iter(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:  # start from root node, find its left child\n            print(n.data, end=\",\")\n            stack.append(n)\n            n = n.left\n        # end of while means current node doesn't have left child\n        n = stack.pop()\n        # start to traverse its right child\n        n = n.right\n\n\ndef in_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order_iter(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:\n            stack.append(n)\n            n = n.left\n        n = stack.pop()\n        print(n.data, end=\",\")\n        n = n.right\n\n\ndef post_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order_iter(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack1, stack2 = [], []\n    n = node\n    stack1.append(n)\n    while stack1:  # to find the reversed order of post order, store it in stack2\n        n = stack1.pop()\n        if n.left:\n            stack1.append(n.left)\n        if n.right:\n            stack1.append(n.right)\n        stack2.append(n)\n    while stack2:  # pop up from stack2 will be the post order\n        print(stack2.pop().data, end=\",\")\n\n\ndef prompt(s: str = \"\", width=50, char=\"*\") -> str:\n    if not s:\n        return \"\\n\" + width * char\n    left, extra = divmod(width - len(s) - 2, 2)\n    return f\"{left * char} {s} {(left + extra) * char}\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(prompt(\"Binary Tree Traversals\"))\n\n    node = build_tree()\n    print(prompt(\"Pre Order Traversal\"))\n    pre_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"In Order Traversal\"))\n    in_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Post Order Traversal\"))\n    post_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Level Order Traversal\"))\n    level_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Actual Level Order Traversal\"))\n    level_order_actual(node)\n    print(\"*\" * 50 + \"\\n\")\n\n    print(prompt(\"Pre Order Traversal - Iteration Version\"))\n    pre_order_iter(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"In Order Traversal - Iteration Version\"))\n    in_order_iter(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Post Order Traversal - Iteration Version\"))\n    post_order_iter(node)\n    print(prompt())\n"},"__N_SSG":true}
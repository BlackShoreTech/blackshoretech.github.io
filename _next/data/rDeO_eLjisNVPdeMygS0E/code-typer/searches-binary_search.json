{"pageProps":{"codeSnippet":"#!/usr/bin/env python3\n\n\"\"\"\nThis is pure Python implementation of binary search algorithms\n\nFor doctests run following command:\npython3 -m doctest -v binary_search.py\n\nFor manual testing run:\npython3 binary_search.py\n\"\"\"\nfrom __future__ import annotations\n\nimport bisect\n\n\ndef bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo\n\n\ndef bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo\n\n\ndef insort_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array before other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_left(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    True\n    >>> item is sorted_collection[2]\n    False\n\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)\n\n\ndef insort_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array after other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_right(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    False\n    >>> item is sorted_collection[2]\n    True\n\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)\n\n\ndef binary_search(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return None\n\n\ndef binary_search_std_lib(sorted_collection: list[int], item: int) -> int | None:\n    \"\"\"Pure implementation of binary search algorithm in Python using stdlib\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    index = bisect.bisect_left(sorted_collection, item)\n    if index != len(sorted_collection) and sorted_collection[index] == item:\n        return index\n    return None\n\n\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int, right: int\n) -> int | None:\n\n    \"\"\"Pure implementation of binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n\n    \"\"\"\n    if right < left:\n        return None\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by comma:\\n\").strip()\n    collection = sorted(int(item) for item in user_input.split(\",\"))\n    target = int(input(\"Enter a single number to be found in the list:\\n\"))\n    result = binary_search(collection, target)\n    if result is None:\n        print(f\"{target} was not found in {collection}.\")\n    else:\n        print(f\"{target} was found at position {result} in {collection}.\")\n"},"__N_SSG":true}